// Generated by CoffeeScript 2.3.1
var Bf;

Bf = class Bf {
  
  constructor(io) {
    this.reset();
    // map of known code characters to interpreter commands
    this.cmd = {
      '>': () => {
        var base, name;
        return (base = this.reg)[name = ++this.ptr] != null ? base[name] : base[name] = 0; // move to the next register
      },
      '<': () => {
        if (--this.ptr < 0) { // move to the previous register
          return this.ptr = 0;
        }
      },
      '+': () => {
        return this.reg[this.ptr]++;
      },
      '-': () => {
        return this.reg[this.ptr]--;
      },
      '.': () => {
        return io != null ? typeof io.write === "function" ? io.write(this.reg[this.ptr]) : void 0 : void 0;
      },
      ',': () => {
        return this.reg[ptr] = (io != null ? typeof io.read === "function" ? io.read() : void 0 : void 0) || 0; // read char code into the current register
      },
      '[': () => {
        return this.mrk.push(this.idx); // start loop
      },
      ']': () => { // rewind idx (and loop again) until reg[ptr] is 0
        if (this.reg[this.ptr]) {
          return this.idx = this.mrk[this.mrk.length - 1];
        } else {
          return this.mrk.pop();
        }
      }
    };
  }

  // parser loop. reads the code char by char
  // and executes mapped command if available.
  // skips all unknown characters (aka code beautyfications)
  // ends after the last character was parsed/executed.
  run(code) {
    var base, name;
    this.idx = 0;
    while (this.idx < code.length) {
      if (typeof (base = this.cmd)[name = code.charAt(this.idx++)] === "function") {
        base[name]();
      }
    }
  }

  
  // (re)init some variables
  reset() {
    this.mrk = [];
    return this.reg = [this.ptr = 0];
  }

};

if (typeof module === 'object') {
  module.exports = Bf;
}
